---
title: Pre-processor Directives
tags: [cpp]
---

These are lines included in the code of programs containing a hash `#` at their start. These aren't program statements but directives for the preprocessor. The preprocessor examines the code before actual compilation of code begins and resolves all these directives before any code is actually generated by regular statements.

These preprocessor directives extend only across a **single line** of code. As soon as a newline character is found, the preprocessor directive is ends. **No semicolon** `;` is expected at the end of a preprocessor directive. The only way a preprocessor directive can extend through more than one line is by preceding the newline character at the end of the line by a backslash `\`

Generally, macros are used just to define certain values, limits or simple expressions. The
naming case used is UPPERCASE by convention, although there's no such restriction

Reference: [CPlusPlus.com](https://cplusplus.com/doc/tutorial/preprocessor/), [GFG](https://www.geeksforgeeks.org/cpp-preprocessors-and-directives/)

## Macro Definitions

Syntax: `#define identifier replacement`

The preprocessor replaces any occurrence of `identifier` in the rest of the code with `replacement`. This second term can be an expression, statement, block or simply anything. Since the preprocessor replacements happen **before any C++ syntax check**, macro definitions can be a tricky feature

```cpp
#include <bits/stdc++.h>
using namespace std;

// Macros:
#define ARRAY_SIZE 100
#define PB push_back
#define SQ(a) a * a
#define CUB(a) (a) * (a) * (a)
#define biggerOne(a, b) ((a) > (b) ? (a) : (b))
#define REP(i, first, last) for (int i = first; i <= last; i++)

int main () {
    int arr[ARRAY_SIZE];
    int n1 = sizeof(arr) / sizeof(int);
    vector<int> nums(ARRAY_SIZE);
    int n2 = nums.size();
    cout << "n1=" << n1 << ", n2=" << n2 << endl;  // n1=100, n2=100

    cout << SQ(2) << endl;      // 4
    cout << SQ(2 + 3) << endl;  // 11 (WRONG)

    cout << CUB(2) << endl;      // 8
    cout << CUB(2 + 3) << endl;  // 125 (CORRECT)

    cout << biggerOne(5, 2) << endl;          // 5
    cout << biggerOne(3.14f, 2.71f) << endl;  // 3.14

    nums.clear();
    nums.PB(1);  // push_back
    nums.push_back(2);
    for (int x : nums) cout << x << ", ";
    cout << endl;  // 1, 2,

    cout << "Squares of numbers 1 to 5:" << endl;
    int i;
    REP(i, 1, 5) cout << i << "^2 = " << SQ(i) << endl;
    // Squares of numbers 1 to 5:
    // 1^2 = 1
    // 2^2 = 4
    // 3^2 = 9
    // 4^2 = 16
    // 5^2 = 25

    return 0;
}
```

Note that `SQ(2+3)` doesn't behave as expected but `CUB(2+3)` does, since we have enclosed each term of expression in `CUB` within parentheses `()`. Don't forget the **BODMAS** operator precedence order for evaluating math expressions

| Macro definition                 | Macro usage | Expansion               | Result |
| -------------------------------- | ----------- | ----------------------- | ------ |
| `#define SQ(a) a * a`            | `SQ(2+3)`   | `2 + 3 * 2 + 3`         | `11`   |
| `#define CUB(a) (a) * (a) * (a)` | `CUB(2+3)`  | `(2+3) * (2+3) * (2+3)` | `125`  |

Defined macros are not affected by block structure. A macro lasts until it is undefined with the `#undef` preprocessor directive:

```cpp
#define ARRAY_SIZE 100
int arr[ARRAY_SIZE];
#undef ARRAY_SIZE

#define ARRAY_SIZE 200
int brr[ARRAY_SIZE];

int main () {
    int n1 = sizeof(arr) / sizeof(int);
    int n2 = sizeof(brr) / sizeof(int);

    printf("n1=%d, n2=%d", n1, n2);
    // n1=100, n2=200
}
```

Function macro definitions accept two special operators `#` and `##` in the replacement sequence. Notice in below example that:

- `str(s) #s` makes whatever is passed in `s` into a string literal by enclosing it in quotes `""`
- `glue(a, b) a##b` concatenates `a` and `b` leaving no blank spaces between them

```cpp
#define str(s) #s
#define glue(a, b) a##b

int main () {
    cout << str(test) << endl;          // test
    cout << str(123) << endl;           // 123
    cout << str(3.14) << endl;          // 3.14
    cout << str(Hello World) << endl;   // Hello World
    cout << str(A bcd 5 3.14) << endl;  // A bcd 5 3.14

    glue(c, out) << "Hello World" << endl;  // Hello World

    int foo = 2, bar = 3, foobar = 4;
    cout << glue(foo, bar) << endl;  // 4
}
```

## Predefined Macros

The following standard macro names are always defined:

`__LINE__` , `__FILE__` , `__DATE__` , `__TIME__` , `__cplusplus` etc.

They all begin and end with **two underscore** characters, `_`

```cpp
int main () {
    cout << "Line number: " << __LINE__ << endl;
    cout << "File: " << __FILE__ << endl;
    cout << "Date: " << __DATE__ << endl;
    cout << "Time: " << __TIME__ << endl;
    cout << "C++ version: " << __cplusplus << endl;
    return 0;
}
// Line number: 6
// File: code.cpp
// Date: Dec 29 2024
// Time: 00:40:36
// C++ version: 201703
```

## Conditional Inclusions

These directives allow to include or discard part of the code of a program if a certain condition is met. These include: `#ifdef` , `#ifndef` , `#if` , `#endif` , `#else` , `#elif`

```cpp
// Define DEBUG_MODE for enabling debug logs:
#define DEBUG_MODE

int main () {
    int a = 2, b = 3;
    int sum = a + b;

#ifdef DEBUG_MODE
    cout << "Inside Debug: Adding " << a << " and " << b << endl;
#endif

#ifndef DEBUG_MODE
    cout << "Debug mode is OFF" << endl;
#endif

    cout << "Sum: " << sum << endl;

    return 0;
}
// Output:
// Inside Debug: Adding 2 and 3
// Sum: 5
```

If we comment out the macro definition line `#define DEBUG_MODE`, we get output as:

```txt
Debug mode is OFF
Sum: 5
```

Thus, there is a conditional compilation of the respective blocks

The `#if`, `#else` and `#elif` directives serve to specify some condition to be met in order for the portion of code they surround to be compiled. The condition that follows `#if` or `#elif` can only evaluate constant expressions, including macro expressions

The behavior of `#ifdef` and `#ifndef` can also be achieved by using the special operators `defined` and `!defined` respectively in any `#if` or `#elif` directive

## Error and Warning directive

The error directive `#error` aborts the compilation process when it is found, generating a compilation error that can be specified as its parameter. In below example, if we comment out the macro definition statement, we get a compile error saying `'PI' must be defined`

```cpp
// Macro definition
#define PI 3.14

#ifndef PI
#error 'PI' must be defined
#endif

int main () {
    cout << "Program is executing" << endl;
    // Program is executing
}
```

However, in `#warning` directive as shown in below example, you get a warning message and the code still compiles even though wee haven't made a `PI` macro definition

```cpp
#ifndef PI
#warning 'PI' must be defined
#endif

int main () {
    cout << "Program is executing" << endl;
    // Program is executing
}
```

## Source File Inclusion

When the preprocessor finds an `#include` directive, it replaces it by the entire content of the specified header or file

```cpp
#include <header>
#include "file"
```

In first case, angle-brackets `<>` are used to include **headers** provided by the implementation, such as the headers that compose the standard library such as `iostream`, `string`, etc. Whether the headers are actually files or exist in some other form is **implementation-defined**, but in any case they shall be properly included with this directive.

In the second case, quotes `""` are used to include a **file**. The file is searched for in an **implementation-defined** manner, which generally includes the current path. In the case that the file is **not found**, the compiler **interprets the directive as a header** inclusion, just as if the quotes `""` were replaced by angle-brackets `<>`

## Pragma directive

This directive is used to specify diverse **options** to the compiler. These options are specific for the platform and the compiler you use. If the compiler does not support a specific argument for `#pragma`, it is ignored - no syntax error is generated

Commonly used `#pragma` flags:

- `#pragma once` : used to include guard for header files
- `#pragma message` : used to print custom messages at the time of compilation
- `#pragma warning` : used to control warning behavior (like enable or disable warnings)
- `#pragma optimize` : used to control optimization settings (manage optimization level)
- `#pragma comment` : used to include some additional information in the object file(or specify linker options)
